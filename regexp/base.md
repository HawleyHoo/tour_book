## 正则表达式

[正则表达式](https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.100).aspx)是一种文本模式，包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为"元字符").

> 正则表达式语言由两种基本字符类型组成：原义（正常）文本字符和元字符。元字符使正则表达式具有处理能力。所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式.

正则表达式有几个用途：用于验证输入、通过grep查看日志、匹配HTML里面的标签.

正则表达式验证工具Kodos http://kodos.sourceforge.net/

 	#	 	正则表达式	 	解释
 	1	 	hi	 	最常见的查找方式，可以查找任何包含hi这两个连续字符的字符
 	2	 	\b	 	【元字符】代表单词的开头或结尾，也就是单词的分界处。只代表位置，不代表字符
 	3	 	*	 	【元字符】【重复】代表数量，它前面的字符可以重复任意次来匹配
 	4	 	.	 	【元字符】【重复】表示除了换行符以外的任意一个字符
 	5	 	\d	 	【元字符】表示一位数字，大括号表示两个连续数字
 	6	 	\s	 	【元字符】任意的空白符（space），包括空格，制表符(Tab)，换行符，中文全角空格等
 	7	 	\w	 	【元字符】匹配字母或数字或下划线或汉字等（word）
 	8	 	^	 	【元字符】和\b类似，表示字符串开始位置
 	9	 	$	 	【元字符】和\b类似，表示字符串结束位置
 	10	 	\	 	【字符转义】查找元字符本身时使用
 	11	 	+	 	【重复】重复一次或更多次
 	12	 	?	 	【重复】前面的字符重复零次或一次
 	13	 	{n}	 	【重复】重复n次
 	14	 	{n,}	 	【重复】重复n次或更多次
 	15	 	{n,m}	 	【重复】重复n到m次
 	16	 	[]	 	【范围】里面填入候选集合，这表示存在于集合中的一个字符。[aeiou]就匹配任何一个英文元音字母；[0-9]表示0到9之间任意一个数字
 	17	 	|	 	【分枝条件】满足其中任意一种规则都应该当成匹配。\d{5}-\d{4}|\d{5}可以认为存在优先级，|优先级高于-
 	18	 	\W	 	【反义】匹配任意不是字母，数字，下划线，汉字的字符
 	19	 	\S	 	【反义】匹配任意不是空白符的字符
 	20	 	\D	 	【反义】匹配任意非数字的字符
 	21	 	\B	 	【反义】匹配不是单词开头或结束的位置
 	22	 	[^x]	 	【反义】匹配除了x以外的任意字符
 	23	 	(exp)	 	【后向引用】【捕获】匹配exp,并捕获文本到自动命名的组里
 	24	 	(?<name>exp)	 	【后向引用】【捕获】匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)
 	25	 	(?:exp)	 	【后向引用】【捕获】匹配exp,不捕获匹配的文本，也不给此分组分配组号
 	26	 	(?=exp)	 	【零宽断言】匹配exp前面的位置
 	27	 	(?<=exp)	 	【零宽断言】匹配exp后面的位置
 	28	 	(?!exp)	 	【零宽断言】匹配后面跟的不是exp的位置
 	29	 	(?<!exp)	 	【零宽断言】匹配前面不是exp的位置
 	30	 	*?	 	【懒惰限定符】重复任意次，但尽可能少重复
 	31	 	+?	 	【懒惰限定符】重复1次或更多次，但尽可能少重复
 	32	 	??	 	【懒惰限定符】重复0次或1次，但尽可能少重复
 	33	 	{n,m}?	 	【懒惰限定符】重复n到m次，但尽可能少重复
 	34	 	{n,}?	 	【懒惰限定符】重复n次以上，但尽可能少重复
 	35	 	(?'group')	 	【递归匹配】把捕获的内容命名为group,并压入堆栈(Stack)
 	36	 	(?'-group')	 	【递归匹配】从堆栈上弹出最后压入堆栈的名为group的捕获内容
 	37	 	(?(group)yes|no)	 	【递归匹配】如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
 	38	 	(?!)	 	【递归匹配】零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

    正则表达式	 	解释
 	^\d{5,12}$	 	QQ号必须为5位到12位数字
 	^\w+	 	匹配一行的第一个单词
 	\(?0\d{2}[) -]?\d{8}	 	(010)88886666，或022-22334455，或02912345678
 	0\d{2}-\d{8}|0\d{3}-\d{7}	 	8位本地号(如010-12345678)和7位本地号(0376-2233445)
 	(\d{1,3}\.){3}\d{1,3}	 	IP地址匹配
 	((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
 	\b(\w+)\b\s+\1\b	 	匹配重复的单词
 	\b\w+(?=ing\b)	 	匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc

## 元字符

- `^` : 开始位置,字符`^`之后的实体(entity),必须在被匹配的字符串开头部分找到;如果将`^`用作括号表达式中的第一个字符，则会对字符集求反
- `$` : 结束位置,在字符`$`前的实体,必须在匹配的字符串尾找打
- `.` : 任意的单个字符,匹配任何字符(除换行符外)
- `[]` : 组(set),匹配指定字符集内的任何字符
- `[^]` : 否定组,匹配任何不包括在指定字符集内的字符串
- `|` : 或,`|`左右两边的一到多个字符当成一个整体对待,匹配符号`|`之前或之后的实体
- `{}` : 标记限定符表达式的开始和结尾
- `()` : 分组,组成一组用于匹配的实体,常于`|`协同使用,即标记子表达式的开始和结尾
- `\` : 转义,允许对一个特殊字符进行转义(即将具有特殊意义的字符转为普通的字符)
- `/` : 表示 JavaScript 中的文本正则表达式模式的开始或结尾.在第二个“/”后添加单字符标志可以指定搜索行为(`g`表示返回匹配到模式的所有项，`i`表示不区分大小写,`m`表示多行匹配)

- `\b` : 匹配某个单词边界，即某个单词和空格之间的位置
- `\B` : 非边界字匹配
- `\d` : 匹配一个数字,等于`[0-9]`
- `\D` : 非数字字符匹配,等于`[^0-9]`
- `\w` : 与以下任意字符匹配：A-Z、a-z、0-9 和下划线,等效于`[A-Za-z0-9_]`
- `\W` : 与除A-Z、a-z、0-9 和下划线意外的任意字符匹配,等效于`[^A-Za-z0-9_]`
- `[xyz]` : 字符集,与其中任意一个指定字符匹配
- `[^xyz]` : 反向字符集,与除字符集外的任何字符匹配
- `[a-z]` : 字符范围,匹配指定范围内的任何字符
- `[^a-z]` : 反向字符范围,与不在指定范围内的任何字符匹配

- `(pattern)` : 与模式 匹配并保存匹配项
- `(?<name>pattern)` : 匹配pattern并且捕获到组`name`
- `(?:pattern)` : 与模式 匹配，但不保存匹配项；即不会存储匹配项以备将来之用
- `(?=pattern)` : 正预测先行(要匹配的字符串，后面必须紧跟着pattern)。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用
- `(?!pattern)` : 负预测先行(要求字符串的后面不能紧跟着某个pattern)。 匹配与模式 不匹配的搜索字符串。 找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。 不会保存匹配项以备将来之用。

- `\cx` : 匹配 x 指示的控制字符。 x 的值必须在 A-Z 或 a-z 范围内。 如果不是这样，则假定 c 就是文本“c”字符本身
- `\xn` : 匹配 n，此处的 n 是一个十六进制转义码。 十六进制转义码必须正好是两位数长。 允许在正则表达式中使用 ASCII 代码
- `\num` : 匹配 num，此处的 num 是一个正整数。 这是对已保存的匹配项的引用
- `\n` : 标识一个八进制转义码或反向引用.如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。 否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。
- `\nm` : 标识一个八进制转义码或反向引用.如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。 如果 \nm 前面至少有 n 个捕获子表达式，则 n 是反向引用，后面跟有文本 m。 如果上述情况都不存在，当 n 和 m 是八进制数字 (0-7) 时，\nm 匹配八进制转义码 nm
- `\nml` : 当 n 是八进制数字 (0-3)，m 和 l 是八进制数字 (0-7) 时，匹配八进制转义码 nml
- `\un` : 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符

## 量词(重复限定符)

定制匹配的次数.

- `*` : 0或多次,等于`{0,}`
- `+` : 至少1次,等于`{1,}`
- `?` : 0或1次,等于`{0,1}`,匹配模式是非贪婪的
- `{n}` : n次,n 是非负整数
- `{n,}` : 至少n次,n 是非负整数
- `{n,m}` : n到m次;n,m 是非负整数,且n<=m

## 非打印字符

- `\f` : 换页符
- `\n` : 换行符
- `\r` : 回车符
- `\s` : 任何空白字符,其中包括空格、制表符和换页符,等同于`[\f\n\r\t\v]`;
- `\S` : 任何非空白字符
- `\t` : Tab 字符
- `\v` : 垂直制表符

## 贪心与非贪心

只要在合法的情况下，正则会尽量多去匹配字符，这就叫做贪心模式.

如果我们希望正则尽量少地匹配字符，那么就可以在表示数字的符号后面加上一个?（即：问号加在量词的后边，则表示非贪婪匹配）,比如：

```
{n,}?, *?, +?, ??, {m,n}?
```

## 反向引用

pattern在匹配时，正则引擎会将小括号 "()" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取.

其实，"小括号包含的表达式所匹配到的字符串" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "\" 加上一个数字。"\1" 引用第1对括号内匹配到的字符串，"\2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。

## 优先级顺序

正则表达式的计算方式与算术表达式非常类似；即从左到右进行计算，并遵循优先级顺序.

| 运算符                     |说明          |
| --------------------------|:-----------:|
| `\`                       | 转义符       |
| `(), (?:), (?=), []`      | 括号和中括号  |
| `*,+,?,{n},{n,},{n,m}`    | 限定符       |
| `^,$,\任何元字符`           | 定位点和序列  |
| `|`                       | 替换         |
